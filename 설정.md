# EKS 클러스터에 IAM OIDC Provider 설정

```
# eksctl 설치 (Amazon Linux 기준)
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
sudo mv /tmp/eksctl /usr/local/bin
eksctl version

# EKS 클러스터에 IAM OIDC Provider 설정
eksctl utils associate-iam-oidc-provider --region=ap-northeast-2 --cluster=tf-eks-cluster --approve

# testcode-namespace 네임스페이스 생성
kubectl create namespace testcode-namespace
```

<br>
<br>
<br>

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
[ec2-user@ip-10-0-1-107 testcode]$ sudo mv /tmp/eksctl /usr/local/bin
[ec2-user@ip-10-0-1-107 testcode]$ eksctl version
0.204.0
[ec2-user@ip-10-0-1-107 testcode]$ eksctl utils associate-iam-oidc-provider --region=ap-northeast-2 --cluster=tf-eks-cluster --approve
2025-02-25 12:18:44 [ℹ]  IAM Open ID Connect provider is already associated with cluster "tf-eks-cluster" in "ap-northeast-2"
```

<br>
<br>
<br>

# IAM 정책 생성 (Secrets Manager 접근 권한 가지는 정책)

```
# IAM 정책 파일 생성 (Secrets Manager 접근 권한 가지는 정책)
cat <<EOF > secrets-irsa-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "secretsmanager:GetSecretValue",
            "Resource": "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds*"
        }
    ]
}
EOF

# AWS에 정책 등록
aws iam create-policy --policy-name SecretsManagerIRSAReadPolicy --policy-document file://secrets-irsa-policy.json

----------
# 이렇게 출력됨 ⇒ 여기서 Arn 사용할 것임
{
    "Policy": {
        "PolicyName": "SecretsManagerIRSAReadPolicy",
        "PolicyId": "ANPA2JRHDGTB2KJVHB36V",
        "Arn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2025-02-19T20:14:54+00:00",
        "UpdateDate": "2025-02-19T20:14:54+00:00"
    }
}
----------

# 등록된 정책 확인
aws iam list-policies --scope Local --query "Policies[?PolicyName=='SecretsManagerIRSAReadPolicy'].[PolicyName,Arn]" --output table

# ARN 확인
aws iam list-policies --scope Local --query "Policies[?PolicyName=='SecretsManagerIRSAReadPolicy'].Arn" --output text
```

<br>
<br>
<br>

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ cat <<EOF > secrets-irsa-policy.json
> {
>     "Version": "2012-10-17",
>     "Statement": [
>         {
>             "Effect": "Allow",
>             "Action": "secretsmanager:GetSecretValue",
>             "Resource": "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds*"
>         }
>     ]
> }
> EOF

[ec2-user@ip-10-0-1-107 testcode]$ ls
deployment.yaml  secrets-irsa-policy.json

[ec2-user@ip-10-0-1-107 testcode]$ aws iam create-policy --policy-name SecretsManagerIRSAReadPolicy --policy-document file://secrets-irsa-policy.json

# 이렇게 출력됨 ⇒ 여기서 Arn 사용할 것임 (있는 정책이어서 오류남..)
{
    "Policy": {
        "PolicyName": "SecretsManagerIRSAReadPolicy",
        "PolicyId": "ANPA2JRHDGTB2KJVHB36V",
        "Arn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2025-02-19T20:14:54+00:00",
        "UpdateDate": "2025-02-19T20:14:54+00:00"
    }
}

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-policies --scope Local --query "Policies[?PolicyName=='SecretsManagerIRSAReadPolicy'].[PolicyName,Arn]" --output table
---------------------------------------------------------------------------------------------------
|                                          ListPolicies                                           |
+-------------------------------+-----------------------------------------------------------------+
|  SecretsManagerIRSAReadPolicy |  arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy  |
+-------------------------------+-----------------------------------------------------------------+

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-policies --scope Local --query "Policies[?PolicyName=='SecretsManagerIRSAReadPolicy'].Arn" --output text
arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
```

<br>
<br>
<br>

# Secrets Manager 접근용 IAM Role 생성 & EKS의 서비스 계정과 연결

```
# IRSA용 IAM Role을 생성하고, EKS의 서비스 계정과 연결 (위 출력에서 Arn 사용함)
eksctl create iamserviceaccount \
 --name secrets-sa \                 # 사용할 Service Account 이름 ⇒ deployment에 연결해 줄 것임
 --namespace testcode-namespace \    # 원하는 네임스페이스
 --cluster tf-eks-cluster \          # 사용 중인 EKS 클러스터 이름
 --attach-policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy \   # 생성한 정책 Arn
 --approve

# 생성된 ServiceAccount 확인
kubectl get sa -n testcode-namespace
kubectl describe sa secrets-sa -n testcode-namespace
```

<br>
<br>
<br>

# 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get sa -n testcode-namespace
NAME      SECRETS   AGE
default   0         3m6s

[ec2-user@ip-10-0-1-107 testcode]$ eksctl create iamserviceaccount \
>  --name secrets-sa \
>  --namespace testcode-namespace \
>  --cluster tf-eks-cluster \
>  --attach-policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy \
>  --approve
2025-02-25 13:07:32 [ℹ]  3 existing iamserviceaccount(s) (default/secrets-access-sa,kube-system/aws-load-balancer-controller,testcode-namespace/secrets-access-sa) will be excluded
2025-02-25 13:07:32 [ℹ]  1 iamserviceaccount (testcode-namespace/secrets-sa) was included (based on the include/exclude rules)
2025-02-25 13:07:32 [!]  serviceaccounts that exist in Kubernetes will be excluded, use --override-existing-serviceaccounts to override
2025-02-25 13:07:32 [ℹ]  1 task: {
    2 sequential sub-tasks: {
        create IAM role for serviceaccount "testcode-namespace/secrets-sa",
        create serviceaccount "testcode-namespace/secrets-sa",
    } }2025-02-25 13:07:32 [ℹ]  building iamserviceaccount stack "eksctl-tf-eks-cluster-addon-iamserviceaccount-testcode-namespace-secrets-sa"
2025-02-25 13:07:32 [ℹ]  deploying stack "eksctl-tf-eks-cluster-addon-iamserviceaccount-testcode-namespace-secrets-sa"
2025-02-25 13:07:32 [ℹ]  waiting for CloudFormation stack "eksctl-tf-eks-cluster-addon-iamserviceaccount-testcode-namespace-secrets-sa"
2025-02-25 13:08:02 [ℹ]  waiting for CloudFormation stack "eksctl-tf-eks-cluster-addon-iamserviceaccount-testcode-namespace-secrets-sa"
2025-02-25 13:08:02 [ℹ]  created serviceaccount "testcode-namespace/secrets-sa"

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get sa -n testcode-namespace
NAME         SECRETS   AGE
default      0         7m26s
secrets-sa   0         95s

[ec2-user@ip-10-0-1-107 testcode]$ kubectl describe sa secrets-sa -n testcode-namespace
Name:                secrets-sa
Namespace:           testcode-namespace
Labels:              app.kubernetes.io/managed-by=eksctl
Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8
Image pull secrets:  <none>
Mountable secrets:   <none>
Tokens:              <none>
Events:              <none>
```

<br>
<br>
<br>

# RDS 연결 관련 IAM Role 생성 & EKS의 서비스 계정과 연결

IAM 기반의 데이터베이스 인증을 사용할 때 필요 <br>
- IAM DB 인증을 활성화한 경우 (IAM으로 로그인할 경우) 필요
- MySQL 자체 계정을 사용하면 불필요

```
cat <<EOF > rds-connect-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "rds-db:connect",
            "Resource": "arn:aws:rds-db:region:account-id:dbuser/rds.tf.private.com/admin"
        }
    ]
}
EOF

# AWS에 정책 등록
aws iam create-policy --policy-name RdsConnectIRSAPolicy --policy-document file://rds-connect-policy.json

# 등록된 정책 확인
aws iam list-policies --scope Local --query "Policies[?PolicyName=='RdsConnectIRSAPolicy'].[PolicyName,Arn]" --output table
aws iam list-policies --scope Local --query "Policies[?PolicyName=='RdsConnectIRSAPolicy'].Arn" --output text

# ServiceAccount 생성 : IAM Role을 생성하고, EKS의 서비스 계정과 연결 (위 출력에서 Arn 사용함)
eksctl create iamserviceaccount \
    --cluster tf-eks-cluster \
    --namespace testcode-namespace \
    --name rds-sa \
    --attach-role-arn arn:aws:iam::arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy \
    --approve

# 생성된 ServiceAccount 확인
kubectl get sa -n testcode-namespace
kubectl describe sa rds-sa -n testcode-namespace
```

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ vi rds-connect-policy.json

[ec2-user@ip-10-0-1-107 testcode]$ aws iam create-policy --policy-name RdsConnectIRSAPolicy --policy-document file://secrets-irsa-policy.json
{
    "Policy": {
        "PolicyName": "RdsConnectIRSAPolicy",
        "PolicyId": "ANPA2JRHDGTBSAOJDHFN3",
        "Arn": "arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2025-02-25T13:42:23+00:00",
        "UpdateDate": "2025-02-25T13:42:23+00:00"
    }
}


[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-policies --scope Local --query "Policies[?PolicyName=='RdsConnectIRSAPolicy'].[PolicyName,Arn]" --output table
-----------------------------------------------------------------------------------
|                                  ListPolicies                                   |
+-----------------------+---------------------------------------------------------+
|  RdsConnectIRSAPolicy |  arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy  |
+-----------------------+---------------------------------------------------------+

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-policies --scope Local --query "Policies[?PolicyName=='RdsConnectIRSAPolicy'].Arn" --output text
arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy

[ec2-user@ip-10-0-1-107 testcode]$ eksctl create iamserviceaccount \
>     --cluster tf-eks-cluster \
>     --namespace testcode-namespace \
>     --name rds-sa \
>     --attach-role-arn arn:aws:iam::arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy \
>     --approve
2025-02-25 13:48:53 [ℹ]  4 existing iamserviceaccount(s) (default/secrets-access-sa,kube-system/aws-load-balancer-controller,testcode-namespace/secrets-access-sa,testcode-namespace/secrets-sa) will be excluded
2025-02-25 13:48:53 [ℹ]  1 iamserviceaccount (testcode-namespace/rds-sa) was included (based on the include/exclude rules)
2025-02-25 13:48:53 [!]  serviceaccounts that exist in Kubernetes will be excluded, use --override-existing-serviceaccounts to override
2025-02-25 13:48:53 [ℹ]  1 task: { create serviceaccount "testcode-namespace/rds-sa" }
2025-02-25 13:48:53 [ℹ]  created serviceaccount "testcode-namespace/rds-sa"

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get sa -n testcode-namespace
NAME         SECRETS   AGE
default      0         47m
rds-sa       0         50s
secrets-sa   0         41m

[ec2-user@ip-10-0-1-107 testcode]$ kubectl describe sa rds-sa -n testcode-namespace
Name:                rds-sa
Namespace:           testcode-namespace
Labels:              app.kubernetes.io/managed-by=eksctl
Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::arn:aws:iam::707677861059:policy/RdsConnectIRSAPolicy
Image pull secrets:  <none>
Mountable secrets:   <none>
Tokens:              <none>
Events:              <none>
```

# externalSecret.yaml 파일 생성, 실행 ⇒ secret 파일 생성됨

이 때, externalsecert이 직접 secrets manager에 접근하는게 아님! <br>
SecretStore (AWS Secrets Manager와 연결)에서 serviceAccountName 사용하는 것임! <br>
즉, IRSA 적용은 ClusterSecretStore에서 처리해야 함 <br>
이 때, IAM 역할(SecretsManagerIRSAReadPolicy)과 연결되어 있는 서비스 어카운트 필요! <br>
이 때, ClusterSecretStore와 ExternalSecret을 동일한 이름으로 맞춰야 함! <br>

<br>
### external-secret.yaml

```
[ec2-user@ip-10-0-1-107 testcode]$ vi external-secret.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mysql-secret
  namespace: testcode-namespace
spec:
  refreshInterval: 1h  # 1시간마다 Secret 동기화
  secretStoreRef:
    name: testcode-aws-secrets-manager      # 원하는 이름 설정 ⇒ ClusterSecretStore의 이름에 넣을 것임
    kind: ClusterSecretStore
  target:
    name: mysql-secret
    creationPolicy: Owner
  data:
    - secretKey: MYSQL_USER
      remoteRef:
        key: rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34  # AWS Secrets Manager에서 가져올 Secret 이름
        property: username        # AWS Secrets Manager 내부의 username 값
    - secretKey: MYSQL_DATABASE
      remoteRef:
        key: rds-mysql-secret
        property: mydb         # AWS Secrets Manager 내부의 database 값: 없으므로 기본값 설정
    - secretKey: MYSQL_PASSWORD
      remoteRef:
        key: rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34
        property: password     # AWS Secrets Manager 내부의 password 값
```

<br>
<br>
<br>

### cluster-secret-store.yaml

```
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: testcode-aws-secrets-manager    # ExternalSecret의 이름과 일치해야 함
spec:
  provider:
    aws:
      service: SecretsManager
      region: ap-northeast-2
      auth:
        jwt:
          serviceAccountRef:
            name: secrets-sa   # IRSA가 적용된 서비스 계정
            namespace: testcode-namespace
```

<br>
<br>
<br>

# deployment.yaml 파일 수정

현재 애플리케이션이 AWS Secrets Manager에서 직접 가져오는 기능이 없으므로, IRSA를 사용할 이유가 없음

```
[ec2-user@ip-10-0-1-107 testcode]$ vi deployment.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testcode-deployment
  namespace: testcode-namespace
  labels:
    app: testcode
spec:
  replicas: 2
  selector:
    matchLabels:
      app: testcode
  template:
    metadata:
      labels:
        app: testcode
    spec:
      # serviceAccountName: secrets-sa     # IRSA 적용 추가
      containers:
      - name: testcode-container
        image: 707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest
        ports:
        - containerPort: 5000
        envFrom:
        - configMapRef:
            name: mysql-config
        env:
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_USER
        - name: MYSQL_DATABASE
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_DATABASE
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret  # 자동 동기화된 비밀번호를 가져옵니다.
              key: MYSQL_PASSWORD
        - name: AWS_REGION
          value: "ap-northeast-2"
```

<br>
<br>
<br>

# 실행 전 단계 : External Secrets Operator 설치

ClusterSecretStore는 Kubernetes 기본 리소스가 아니라, External Secrets Operator를 설치해야 사용할 수 있음

<br>

### Helm 설치

```
# Helm 설치
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# 설치 확인
helm version

# Helm 저장소 추가
helm repo add external-secrets https://charts.external-secrets.io

# Helm 저장소 업데이트
helm repo update
```

<br>
<br>
<br>

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 11913  100 11913    0     0  35470      0 --:--:-- --:--:-- --:--:-- 35561
[WARNING] Could not find git. It is required for plugin installation.
Downloading https://get.helm.sh/helm-v3.17.1-linux-amd64.tar.gz
Verifying checksum... Done.
Preparing to install helm into /usr/local/bin
helm installed into /usr/local/bin/helm

[ec2-user@ip-10-0-1-107 testcode]$ helm version
version.BuildInfo{Version:"v3.17.1", GitCommit:"980d8ac1939e39138101364400756af2bdee1da5", GitTreeState:"clean", GoVersion:"go1.23.5"}

[ec2-user@ip-10-0-1-107 testcode]$ helm repo add external-secrets https://charts.external-secrets.io
"external-secrets" has been added to your repositories

[ec2-user@ip-10-0-1-107 testcode]$ helm repo update
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "external-secrets" chart repository
Update Complete. ⎈Happy Helming!⎈
```

<br>
<br>
<br>

### External Secrets Operator 설치

```
# External Secrets Operator 설치
helm install external-secrets external-secrets/external-secrets --namespace kube-system

# 설치 확인
kubectl get pods -n kube-system | grep external-secrets

# CRD 확인
kubectl get crds | grep external-secrets
```

<br>

CRD 확인할 때, clustersecretstores.external-secrets.io 가 보이면 정상설치 된 것임

<br>
<br>
<br>

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ helm install external-secrets external-secrets/external-secrets --namespace kube-system
NAME: external-secrets
LAST DEPLOYED: Tue Feb 25 14:37:25 2025
NAMESPACE: kube-system
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
external-secrets has been deployed successfully in namespace kube-system!

In order to begin using ExternalSecrets, you will need to set up a SecretStore
or ClusterSecretStore resource (for example, by creating a 'vault' SecretStore).

More information on the different types of SecretStores and how to configure them
can be found in our Github: https://github.com/external-secrets/external-secrets

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get pods -n kube-system | grep external-secrets
external-secrets-55dbcddd4-s9gv7                   1/1     Running   0          2m52s
external-secrets-cert-controller-cd4b6c759-6qjbl   1/1     Running   0          2m52s
external-secrets-webhook-765f96bb45-2ngs8          1/1     Running   0          2m52s

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get crds | grep external-secrets
acraccesstokens.generators.external-secrets.io          2025-02-25T14:37:27Z
clusterexternalsecrets.external-secrets.io              2025-02-25T14:37:27Z
clustergenerators.generators.external-secrets.io        2025-02-25T14:37:27Z
clustersecretstores.external-secrets.io                 2025-02-25T14:37:27Z
ecrauthorizationtokens.generators.external-secrets.io   2025-02-25T14:37:26Z
externalsecrets.external-secrets.io                     2025-02-25T14:37:27Z
fakes.generators.external-secrets.io                    2025-02-25T14:37:26Z
gcraccesstokens.generators.external-secrets.io          2025-02-25T14:37:27Z
generatorstates.generators.external-secrets.io          2025-02-25T14:37:27Z
githubaccesstokens.generators.external-secrets.io       2025-02-25T14:37:27Z
grafanas.generators.external-secrets.io                 2025-02-25T14:37:26Z
passwords.generators.external-secrets.io                2025-02-25T14:37:26Z
pushsecrets.external-secrets.io                         2025-02-25T14:37:27Z
quayaccesstokens.generators.external-secrets.io         2025-02-25T14:37:27Z
secretstores.external-secrets.io                        2025-02-25T14:37:27Z
stssessiontokens.generators.external-secrets.io         2025-02-25T14:37:27Z
uuids.generators.external-secrets.io                    2025-02-25T14:37:27Z
vaultdynamicsecrets.generators.external-secrets.io      2025-02-25T14:37:27Z
webhooks.generators.external-secrets.io                 2025-02-25T14:37:26Z
```

<br>
<br>
<br>

# yaml 파일 실행 순서

```
kubectl apply -f cluster-secret-store.yaml
kubectl apply -f external-secret.yaml
kubectl apply -f configmap.yaml
kubectl apply -f deployment.yaml
```

### 코드

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f cluster-secret-store.yaml
clustersecretstore.external-secrets.io/testcode-aws-secrets-manager created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f external-secret.yaml
externalsecret.external-secrets.io/mysql-secret created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f configmap.yaml
configmap/mysql-config created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f deployment.yaml
deployment.apps/testcode-deployment created
```

<br>
<br>
<br>

# external-secret.yaml 파일에 오류있음

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get all -n testcode-namespace
NAME                                       READY   STATUS                       RESTARTS   AGE
pod/testcode-deployment-65d678496c-qmqfh   0/1     CreateContainerConfigError   0          40s
pod/testcode-deployment-65d678496c-zr9rc   0/1     CreateContainerConfigError   0          40s

NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/testcode-deployment   0/2     2            0           41s

NAME                                             DESIRED   CURRENT   READY   AGE
replicaset.apps/testcode-deployment-65d678496c   2         2         0       41s



[ec2-user@ip-10-0-1-107 testcode]$ kubectl describe pod/testcode-deployment-65d678496c-qmqfh -n testcode-namespace
Name:             testcode-deployment-65d678496c-qmqfh
Namespace:        testcode-namespace
Priority:         0
Service Account:  default
Node:             ip-10-0-3-53.ap-northeast-2.compute.internal/10.0.3.53
Start Time:       Tue, 25 Feb 2025 14:42:22 +0000
Labels:           app=testcode
                  pod-template-hash=65d678496c
Annotations:      <none>
Status:           Pending
IP:               10.0.3.197
IPs:
  IP:           10.0.3.197
Controlled By:  ReplicaSet/testcode-deployment-65d678496c
Containers:
  testcode-container:
    Container ID:
    Image:          707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest
    Image ID:
    Port:           5000/TCP
    Host Port:      0/TCP
    State:          Waiting
      Reason:       CreateContainerConfigError
    Ready:          False
    Restart Count:  0
    Environment Variables from:
      mysql-config  ConfigMap  Optional: false
    Environment:
      MYSQL_USER:      <set to the key 'MYSQL_USER' in secret 'mysql-secret'>      Optional: false
      MYSQL_DATABASE:  <set to the key 'MYSQL_DATABASE' in secret 'mysql-secret'>  Optional: false
      MYSQL_PASSWORD:  <set to the key 'MYSQL_PASSWORD' in secret 'mysql-secret'>  Optional: false
      AWS_REGION:      ap-northeast-2
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-mnxt4 (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       False
  ContainersReady             False
  PodScheduled                True
Volumes:
  kube-api-access-mnxt4:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       <nil>
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type     Reason     Age                 From               Message
  ----     ------     ----                ----               -------
  Normal   Scheduled  2m2s                default-scheduler  Successfully assigned testcode-namespace/testcode-deployment-65d678496c-qmqfh to ip-10-0-3-53.ap-northeast-2.compute.internal
  Normal   Pulled     114s                kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 7.507s (7.507s including waiting). Image size: 169902537 bytes.
  Normal   Pulled     113s                kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 145ms (145ms including waiting). Image size: 169902537 bytes.
  Normal   Pulled     99s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 138ms (138ms including waiting). Image size: 169902537 bytes.
  Normal   Pulled     88s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 145ms (146ms including waiting). Image size: 169902537 bytes.
  Normal   Pulled     76s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 148ms (148ms including waiting). Image size: 169902537 bytes.
  Normal   Pulled     63s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 147ms (147ms including waiting). Image size: 169902537 bytes.
  Normal   Pulled     52s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 151ms (151ms including waiting). Image size: 169902537 bytes.
  Warning  Failed     38s (x8 over 114s)  kubelet            Error: secret "mysql-secret" not found
  Normal   Pulled     38s                 kubelet            Successfully pulled image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest" in 146ms (146ms including waiting). Image size: 169902537 bytes.
  Normal   Pulling    23s (x9 over 2m2s)  kubelet            Pulling image "707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest"



[ec2-user@ip-10-0-1-107 testcode]$ kubectl get secret -n testcode-namespace
No resources found in testcode-namespace namespace.

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get externalsecret -n testcode-namespace
NAME           STORETYPE            STORE                          REFRESH INTERVAL   STATUS              READY
mysql-secret   ClusterSecretStore   testcode-aws-secrets-manager   1h                 SecretSyncedError   False



[ec2-user@ip-10-0-1-107 testcode]$ kubectl describe externalsecret mysql-secret -n testcode-namespace
Name:         mysql-secret
Namespace:    testcode-namespace
Labels:       <none>
Annotations:  <none>
API Version:  external-secrets.io/v1beta1
Kind:         ExternalSecret
Metadata:
  Creation Timestamp:  2025-02-25T14:42:14Z
  Generation:          1
  Resource Version:    65595
  UID:                 56bf26ed-51a6-4c61-8b6f-f4443cbd3890
Spec:
  Data:
    Remote Ref:
      Conversion Strategy:  Default
      Decoding Strategy:    None
      Key:                  rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34
      Metadata Policy:      None
      Property:             username
    Secret Key:             MYSQL_USER
    Remote Ref:
      Conversion Strategy:  Default
      Decoding Strategy:    None
      Key:                  rds-mysql-secret
      Metadata Policy:      None
      Property:             mydb
    Secret Key:             MYSQL_DATABASE
    Remote Ref:
      Conversion Strategy:  Default
      Decoding Strategy:    None
      Key:                  rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34
      Metadata Policy:      None
      Property:             password
    Secret Key:             MYSQL_PASSWORD
  Refresh Interval:         1h
  Secret Store Ref:
    Kind:  ClusterSecretStore
    Name:  testcode-aws-secrets-manager
  Target:
    Creation Policy:  Owner
    Deletion Policy:  Retain
    Name:             mysql-secret
Status:
  Binding:
    Name:
  Conditions:
    Last Transition Time:  2025-02-25T14:42:14Z
    Message:               could not get secret data from provider
    Reason:                SecretSyncedError
    Status:                False
    Type:                  Ready
  Refresh Time:            <nil>
Events:
  Type     Reason        Age                  From              Message
  ----     ------        ----                 ----              -------
  Warning  UpdateFailed  60s (x9 over 5m14s)  external-secrets  error processing spec.data[1] (key: rds-mysql-secret), err: AccessDeniedException: User: arn:aws:sts::707677861059:assumed-role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8/external-secrets-provider-aws is not authorized to perform: secretsmanager:GetSecretValue on resource: rds-mysql-secret because no identity-based policy allows the secretsmanager:GetSecretValue action
           status code: 400,
```

<br>
<br>
<br>

### 오류 해결 코드

<br>

#### SecretStore가 정상적으로 설정되었는지 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get clustersecretstore testcode-aws-secrets-manager -o yaml
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"external-secrets.io/v1beta1","kind":"ClusterSecretStore","metadata":{"annotations":{},"name":"testcode-aws-secrets-manager"},"spec":{"provider":{"aws":{"auth":{"jwt":{"serviceAccountRef":{"name":"secrets-sa","namespace":"testcode-namespace"}}},"region":"ap-northeast-2","service":"SecretsManager"}}}}
  creationTimestamp: "2025-02-25T14:42:10Z"
  generation: 1
  name: testcode-aws-secrets-manager
  resourceVersion: "65573"
  uid: 9e6e75ab-b337-4374-8567-00bbbb55614b
spec:
  provider:
    aws:
      auth:
        jwt:
          serviceAccountRef:
            name: secrets-sa
            namespace: testcode-namespace
      region: ap-northeast-2
      service: SecretsManager
status:
  capabilities: ReadWrite
  conditions:
  - lastTransitionTime: "2025-02-25T14:42:10Z"
    message: store validated
    reason: Valid
    status: "True"
    type: Ready
```

<br>

###  IAM 역할(IRSA)에 SecretsManager:GetSecretValue 권한이 있는지 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ aws eks describe-cluster --name tf-eks-cluster --query "cluster.identity.oidc.issuer" --output text
https://oidc.eks.ap-northeast-2.amazonaws.com/id/6E3E6C04629E597FA0BCF4FE468F4B80

[ec2-user@ip-10-0-1-107 testcode]$ aws iam get-policy --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
{
    "Policy": {
        "PolicyName": "SecretsManagerIRSAReadPolicy",
        "PolicyId": "ANPA2JRHDGTBUSGYRH2X7",
        "Arn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 2,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2025-02-24T07:07:32+00:00",
        "UpdateDate": "2025-02-24T07:07:32+00:00",
        "Tags": []
    }
}

[ec2-user@ip-10-0-1-107 testcode]$ aws iam get-policy-version --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy --version-id v1
{
    "PolicyVersion": {
        "Document": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": "secretsmanager:GetSecretValue",
                    "Resource": "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!*"
                }
            ]
        },
        "VersionId": "v1",
        "IsDefaultVersion": true,
        "CreateDate": "2025-02-24T07:07:32+00:00"
    }
}
```

### 현재 Secret ARN 찾아서 정확하게 입력해주기

```
[ec2-user@ip-10-0-1-107 testcode]$ aws secretsmanager list-secrets --query "SecretList[*].ARN"
[
    "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN"
]

[ec2-user@ip-10-0-1-107 testcode]$ vi external-secret.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mysql-secret
  namespace: testcode-namespace
spec:
  refreshInterval: 1h  # 1시간마다 Secret 동기화
  secretStoreRef:
    name: testcode-aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: mysql-secret
    creationPolicy: Owner
  data:
    - secretKey: MYSQL_USER
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN'  # AWS Secrets Manager에서 가져올 Secret 이름
        property: username        # AWS Secrets Manager 내부의 username 값
    - secretKey: MYSQL_DATABASE
      remoteRef:
        # key: rds-mysql-secret
        property: mydb         # AWS Secrets Manager 내부의 database 값: 없으므로 기본값 설정
    - secretKey: MYSQL_PASSWORD
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN'
        property: password     # AWS Secrets Manager 내부의 password 값



[ec2-user@ip-10-0-1-107 testcode]$ cat secrets-irsa-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "secretsmanager:GetSecretValue",
            "Resource": "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds*"
        }
    ]
}

[ec2-user@ip-10-0-1-107 testcode]$ vi secrets-irsa-policy.json
[ec2-user@ip-10-0-1-107 testcode]$ cat secrets-irsa-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "secretsmanager:GetSecretValue",
            "Resource": [
                "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!*",
                "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN"
            ]
        }
    ]
}

```

<br>

### IAM Role과 secrets-sa 서비스 계정 연결 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ aws eks describe-cluster --name tf-eks-cluster --query "cluster.identity.oidc.issuer" --output text
https://oidc.eks.ap-northeast-2.amazonaws.com/id/6E3E6C04629E597FA0BCF4FE468F4B80
[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-roles | grep eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8",
            "Arn": "arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8",
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-6t1BDAgaKJeb",
            "Arn": "arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-6t1BDAgaKJeb",
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-GBqVGhEkRw47",
            "Arn": "arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-GBqVGhEkRw47",
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-LFz07EEwJXKl",
            "Arn": "arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-LFz07EEwJXKl",
```

<br>

### 서비스 계정 정보 확인 ⇒ 정확히 어떤 롤에 정책이 연결되어있는지 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get serviceaccount secrets-sa -n testcode-namespace -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8
  creationTimestamp: "2025-02-25T13:08:02Z"
  labels:
    app.kubernetes.io/managed-by: eksctl
  name: secrets-sa
  namespace: testcode-namespace
  resourceVersion: "36743"
  uid: f2181443-0f9d-495d-9911-90a2df780eb2

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-attached-role-policies --role-name eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8
{
    "AttachedPolicies": [
        {
            "PolicyName": "SecretsManagerIRSAReadPolicy",
            "PolicyArn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy"
        }
    ]
}
```

<br>
<br>
<br>

### 정책이 연결된 역할(Role) 확인, IAM 정책을 역할(Role)에서 분리

```
[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-entities-for-policy --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
{
    "PolicyGroups": [],
    "PolicyUsers": [],
    "PolicyRoles": [
        {
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8",
            "RoleId": "AROA2JRHDGTBRVLXH6N6N"
        },
        {
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-GBqVGhEkRw47",
            "RoleId": "AROA2JRHDGTBYMTRNWC6J"
        }
    ]
}

[ec2-user@ip-10-0-1-107 testcode]$ aws iam detach-role-policy --role-name eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8 --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
[ec2-user@ip-10-0-1-107 testcode]$ aws iam detach-role-policy --role-name eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-GBqVGhEkRw47 --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-entities-for-policy --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
{
    "PolicyGroups": [],
    "PolicyUsers": [],
    "PolicyRoles": []
}
```

<br>
<br>
<br>

### 기존 IAM 정책 삭제, 새로운 IAM 정책 다시 연결

```
[ec2-user@ip-10-0-1-107 testcode]$ aws iam delete-policy --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy

[ec2-user@ip-10-0-1-107 testcode]$ ls
cluster-secret-store.yaml  configmap.yaml  deployment.yaml  external-secret.yaml  rds-connect-policy.json  secrets-irsa-policy.json  secret.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat secrets-irsa-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "secretsmanager:GetSecretValue",
            "Resource": [
                "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!*",
                "arn:aws:secretsmanager:ap-northeast-2:707677861059:secret:rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN"
            ]
        }
    ]
}

[ec2-user@ip-10-0-1-107 testcode]$ aws iam create-policy --policy-name SecretsManagerIRSAReadPolicy --policy-document file://secrets-irsa-policy.json
{
    "Policy": {
        "PolicyName": "SecretsManagerIRSAReadPolicy",
        "PolicyId": "ANPA2JRHDGTBRHJP7DK7Y",
        "Arn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2025-02-25T15:21:11+00:00",
        "UpdateDate": "2025-02-25T15:21:11+00:00"
    }
}
```

<br>

### EKS의 secrets-sa 서비스 계정이 사용하는 IAM Role 확인, 새로 만든 정책을 IAM Role과 연결, IAM 정책이 정상적으로 연결되었는지 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get serviceaccount secrets-sa -n testcode-namespace -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::707677861059:role/eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8
  creationTimestamp: "2025-02-25T13:08:02Z"
  labels:
    app.kubernetes.io/managed-by: eksctl
  name: secrets-sa
  namespace: testcode-namespace
  resourceVersion: "36743"
  uid: f2181443-0f9d-495d-9911-90a2df780eb2



[ec2-user@ip-10-0-1-107 testcode]$ aws iam attach-role-policy --role-name eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8 --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy



[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-attached-role-policies --role-name eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8
{
    "AttachedPolicies": [
        {
            "PolicyName": "SecretsManagerIRSAReadPolicy",
            "PolicyArn": "arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy"
        }
    ]
}

[ec2-user@ip-10-0-1-107 testcode]$ aws iam list-entities-for-policy --policy-arn arn:aws:iam::707677861059:policy/SecretsManagerIRSAReadPolicy
{
    "PolicyGroups": [],
    "PolicyUsers": [],
    "PolicyRoles": [
        {
            "RoleName": "eksctl-tf-eks-cluster-addon-iamserviceaccount-Role1-3B2qkywb73P8",
            "RoleId": "AROA2JRHDGTBRVLXH6N6N"
        }
    ]
}
```

<br>

### 중간에 external-secret.yaml apply 오류나서 파일 수정함

database값 configmap으로 옮김

```
[ec2-user@ip-10-0-1-107 testcode]$ cat external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mysql-secret
  namespace: testcode-namespace
spec:
  refreshInterval: 1h  # 1시간마다 Secret 동기화
  secretStoreRef:
    name: testcode-aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: mysql-secret
    creationPolicy: Owner
  data:
    - secretKey: MYSQL_USER
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN'  # AWS Secrets Manager에서 가져올 Secret 이름
        property: username        # AWS Secrets Manager 내부의 username 값
    - secretKey: MYSQL_PASSWORD
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34-yhk7PN'
        property: password     # AWS Secrets Manager 내부의 password 값

[ec2-user@ip-10-0-1-107 testcode]$ cat deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: testcode-deployment
  namespace: testcode-namespace
  labels:
    app: testcode
spec:
  replicas: 2
  selector:
    matchLabels:
      app: testcode
  template:
    metadata:
      labels:
        app: testcode
    spec:
      # serviceAccountName: secrets-sa     # IRSA 적용 추가
      containers:
      - name: testcode-container
        image: 707677861059.dkr.ecr.ap-northeast-2.amazonaws.com/testcodeecr:latest
        ports:
        - containerPort: 5000
        envFrom:
        - configMapRef:
            name: mysql-config  # ConfigMap에서 MYSQL_DATABASE 값을 가져옴
        env:
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_USER
        # - name: MYSQL_DATABASE
          # valueFrom:
              # secretKeyRef:
                # name: mysql-secret
                # key: MYSQL_DATABASE
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret  # 자동 동기화된 비밀번호를 가져옵니다.
              key: MYSQL_PASSWORD
        - name: AWS_REGION
          value: "ap-northeast-2"
```

<br>

# 코드 실행

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f cluster-secret-store.yaml
clustersecretstore.external-secrets.io/testcode-aws-secrets-manager created

#  [ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f external-secret.yaml
#  The ExternalSecret "mysql-secret" is invalid: spec.data[1].remoteRef.key: Required value
#  코드 수정하고 여기서부터 다시 함

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f configmap.yaml
configmap/mysql-config created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f external-secret.yaml
externalsecret.external-secrets.io/mysql-secret created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f deployment.yaml
deployment.apps/testcode-deployment created
```

<br>
<br>
<br>

# 여전히 오류 있음

ExternalSecret이 AWS Secrets Manager에서 값을 가져오지 못해서 mysql-secret이 생성되지 않음 <br>
즉, Deployment는 mysql-secret을 참조해야 하는데, Secret이 없어서 Pod 생성 실패

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get all -n testcode-namespace
NAME                                       READY   STATUS                       RESTARTS   AGE
pod/testcode-deployment-6c77d8c4d8-2w55g   0/1     CreateContainerConfigError   0          63s
pod/testcode-deployment-6c77d8c4d8-9mtcl   0/1     CreateContainerConfigError   0          63s

NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/testcode-deployment   0/2     2            0           63s

NAME                                             DESIRED   CURRENT   READY   AGE
replicaset.apps/testcode-deployment-6c77d8c4d8   2         2         0       63s


[ec2-user@ip-10-0-1-107 testcode]$ kubectl get externalsecret -n testcode-namespace
NAME           STORETYPE            STORE                          REFRESH INTERVAL   STATUS              READY
mysql-secret   ClusterSecretStore   testcode-aws-secrets-manager   1h                 SecretSyncedError   False
```

<br>

### 문제 해결

IAM 정책(secrets-irsa-policy.json)에서는 Secret의 ARN 사용 <br>
ExternalSecret(external-secret.yaml)에서는 Secret의 이름 사용 <br>

IAM 정책은 AWS 리소스에 대한 접근을 제어하기 때문에 "ARN"을 사용해야 하고, <br>
Kubernetes ExternalSecret은 AWS Secrets Manager에서 Secret을 찾을 때 이름을 사용함

```
[ec2-user@ip-10-0-1-107 testcode]$ cat external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mysql-secret
  namespace: testcode-namespace
spec:
  refreshInterval: 1h  # 1시간마다 Secret 동기화
  secretStoreRef:
    name: testcode-aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: mysql-secret
    creationPolicy: Owner
  data:
    - secretKey: MYSQL_USER
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34'  # AWS Secrets Manager에서 가져올 Secret 이름!!! ARN 가져오면 안됨!!
        property: username        # AWS Secrets Manager 내부의 username 값
    - secretKey: MYSQL_PASSWORD
      remoteRef:
        key: 'rds!db-cbca25ff-3da5-473d-9b16-599c84a39c34'
        property: password     # AWS Secrets Manager 내부의 password 값
```

<br>
<br>
<br>

# 성공

```
[ec2-user@ip-10-0-1-107 testcode]$ ls
cluster-secret-store.yaml  configmap.yaml  deployment.yaml  external-secret.yaml  rds-connect-policy.json  secrets-irsa-policy.json  secret.yaml
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f cluster-secret-store.yaml
clustersecretstore.external-secrets.io/testcode-aws-secrets-manager created
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f configmap.yaml
configmap/mysql-config created
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f external-secret.yaml
externalsecret.external-secrets.io/mysql-secret created
[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f deployment.yaml
deployment.apps/testcode-deployment created
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get all -n testcode-namespace
NAME                                       READY   STATUS    RESTARTS   AGE
pod/testcode-deployment-6c77d8c4d8-2kzhc   1/1     Running   0          11s
pod/testcode-deployment-6c77d8c4d8-hgpqb   1/1     Running   0          11s

NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/testcode-deployment   2/2     2            2           11s

NAME                                             DESIRED   CURRENT   READY   AGE
replicaset.apps/testcode-deployment-6c77d8c4d8   2         2         2       11s
```

<br>
<br>
<br>

# 연결 성공

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl get pods -o wide -n testcode-namespace
NAME                                   READY   STATUS    RESTARTS   AGE     IP           NODE                                           NOMINATED NODE   READINESS GATES
testcode-deployment-6c77d8c4d8-2kzhc   1/1     Running   0          2m11s   10.0.3.197   ip-10-0-3-53.ap-northeast-2.compute.internal   <none>           <none>
testcode-deployment-6c77d8c4d8-hgpqb   1/1     Running   0          2m11s   10.0.4.66    ip-10-0-4-40.ap-northeast-2.compute.internal   <none>           <none>

[ec2-user@ip-10-0-1-107 testcode]$ kubectl exec testcode-deployment-6c77d8c4d8-2kzhc -it -n testcode-namespace -- curl localhost:5000

    <h1>상품 관리</h1>
    <form method="POST" action="/add">
        <label for="item">물건 이름:</label><br>
        <input type="text" id="item" name="item"><br>
        <label for="price">가격:</label><br>
        <input type="number" id="price" name="price"><br><br>
        <button type="submit">추가</button>
    </form>
    <br>
    <a href="/items">저장된 상품 보기</a>

[ec2-user@ip-10-0-1-107 testcode]$ kubectl exec testcode-deployment-6c77d8c4d8-2kzhc -it -n testcode-namespace -- curl localhost:5000/items
<h1>오류 발생: (1146, "Table 'mydb.items' doesn't exist")</h1><br><a href='/'>다시 시도하기</a>
```

<br>
<br>
<br>

# 테이블 생성하기, 확인용 데이터 삽입

```
[ec2-user@ip-10-0-1-107 testcode]$ sudo yum install mysql
Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
...[생략]...
Installed:
  mariadb.x86_64 1:5.5.68-1.amzn2.0.1

Complete!

[ec2-user@ip-10-0-1-107 testcode]$ mysql --version
mysql  Ver 15.1 Distrib 5.5.68-MariaDB, for Linux (x86_64) using readline 5.1

[ec2-user@ip-10-0-1-107 testcode]$ mysql -u admin -h rds.tf.private.com -p'<password>'
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 84
Server version: 8.0.40 Source distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mydb               |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.01 sec)

MySQL [(none)]> use mydb;
Database changed
MySQL [mydb]> show tables;
Empty set (0.00 sec)

MySQL [mydb]> CREATE TABLE items (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, price DECIMAL(10, 2) NOT NULL);
Query OK, 0 rows affected (0.09 sec)

MySQL [mydb]> show tables;
+----------------+
| Tables_in_mydb |
+----------------+
| items          |
+----------------+
1 row in set (0.00 sec)

MySQL [mydb]> select * from items;
Empty set (0.00 sec)

MySQL [mydb]> INSERT INTO items (name, price) VALUES ('Americano', 2000.00);
Query OK, 1 row affected (0.00 sec)

MySQL [mydb]> select * from items;
+----+-----------+---------+
| id | name      | price   |
+----+-----------+---------+
|  1 | Americano | 2000.00 |
+----+-----------+---------+
1 row in set (0.00 sec)

MySQL [mydb]> exit
Bye
```

<br>
<br>
<br>

### 데이터 반영 잘 됨

```
[ec2-user@ip-10-0-1-107 testcode]$ kubectl exec testcode-deployment-6c77d8c4d8-2kzhc -it -n testcode-namespace -- curl localhost:5000/items
<h1>저장된 상품 목록</h1><ul><li>Americano - 2000.00원</li></ul><br><a href='/'>상품 추가하기</a>
```

<br>
<br>
<br>

# 서비스(ClusterIP) 생성

```
[ec2-user@ip-10-0-1-107 testcode]$ vi svc-cip.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat svc-cip.yaml
apiVersion: v1
kind: Service
metadata:
  name: testcode-svc
  namespace: testcode-namespace
spec:
  ports:
  - name: 8080-5000
    port: 8080
    protocol: TCP
    targetPort: 5000
  selector:
    app: testcode
  type: ClusterIP

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f svc-cip.yaml
service/testcode-svc created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get svc -n testcode-namespace
NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
testcode-svc   ClusterIP   172.20.28.60   <none>        8080/TCP   17s

[ec2-user@ip-10-0-1-107 testcode]$ kubectl run shell -it --rm --image centos:7 bash
If you don't see a command prompt, try pressing enter.

[root@shell /]# curl 172.20.28.60:8080

    <h1>상품 관리</h1>
    <form method="POST" action="/add">
        <label for="item">물건 이름:</label><br>
        <input type="text" id="item" name="item"><br>
        <label for="price">가격:</label><br>
        <input type="number" id="price" name="price"><br><br>
        <button type="submit">추가</button>
    </form>
    <br>
    <a href="/items">저장된 상품 보기</a>
    [root@shell /]# curl 172.20.28.60:8080/items
<h1>저장된 상품 목록</h1><ul><li>Americano - 2000.00원</li></ul><br><a href='/'>상품 추가하기</a>

[root@shell /]# exit
exit
Session ended, resume using 'kubectl attach shell -c shell -i -t' command when the pod is running
pod "shell" deleted

[ec2-user@ip-10-0-1-107 testcode]$

```

<br>
<br>
<br>

# 인그래스 생성

```
[ec2-user@ip-10-0-1-107 testcode]$ vi ingress-alb.yaml
[ec2-user@ip-10-0-1-107 testcode]$ cat ingress-alb.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: testcode-ingress
  namespace: testcode-namespace
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing   # 내부용이면 "internal"
    alb.ingress.kubernetes.io/target-type: ip          # IP 모드 (또는 "instance")
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
    alb.ingress.kubernetes.io/group.name: "testcode-ingress-group"
spec:
  ingressClassName: alb
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: testcode-svc
            port:
              number: 8080

[ec2-user@ip-10-0-1-107 testcode]$ kubectl apply -f ingress-alb.yaml
ingress.networking.k8s.io/testcode-ingress created

[ec2-user@ip-10-0-1-107 testcode]$ kubectl get ingress -n testcode-namespace
NAME               CLASS   HOSTS   ADDRESS                                                                        PORTS   AGE
testcode-ingress   alb     *       k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com   80      10s

[ec2-user@ip-10-0-1-107 testcode]$ curl k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com
curl: (6) Could not resolve host: k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com
```

<br>

### 로들밸런서

![image](https://github.com/user-attachments/assets/9abb6401-2d00-4787-8383-99424c0deff6)
![image](https://github.com/user-attachments/assets/acc97138-946b-4a59-8cc4-3495adbd071f)
![image](https://github.com/user-attachments/assets/1c22c88a-3913-4737-89e3-7dae804ad1f5)
![image](https://github.com/user-attachments/assets/eedffe73-4be8-416f-b8ca-6e825a219bba)
![image](https://github.com/user-attachments/assets/26281be1-087b-453e-9677-559f690bed81)
![image](https://github.com/user-attachments/assets/9101b62a-23e8-42ec-aefb-7fa275bda48f)
![image](https://github.com/user-attachments/assets/07b4f701-1cb4-4d98-aff1-89cc7a43b87f)

<br>
<br>
<br>

### 대상그룹

![image](https://github.com/user-attachments/assets/3d0bf181-3e3f-4937-b82d-dd9f6c9a12ae)
![image](https://github.com/user-attachments/assets/7e568d27-6add-460b-a031-5cf15fad772b)


<br>
<br>
<br>

alb 생성하는데 시간 조금 걸림


![image](https://github.com/user-attachments/assets/5e3bbafb-adc5-4642-b287-2e2a6604bbad)


<br>

### 인그래스도 잘 작동함

```
[ec2-user@ip-10-0-1-107 testcode]$ curl k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com

    <h1>상품 관리</h1>
    <form method="POST" action="/add">
        <label for="item">물건 이름:</label><br>
        <input type="text" id="item" name="item"><br>
        <label for="price">가격:</label><br>
        <input type="number" id="price" name="price"><br><br>
        <button type="submit">추가</button>
    </form>
    <br>
    <a href="/items">저장된 상품 보기</a>

[ec2-user@ip-10-0-1-107 testcode]$ curl k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com/items
<h1>저장된 상품 목록</h1><ul><li>Americano - 2000.00원</li></ul><br><a href='/'>상품 추가하기</a>
```

<br>
<br>
<br>

# 웹에서 넣어보기

![image](https://github.com/user-attachments/assets/1ac0be47-ea3a-4567-b4e3-7e8903490b5a)

<br>

![image](https://github.com/user-attachments/assets/d596968d-b34d-46b1-819e-39950962575a)

<br>

![image](https://github.com/user-attachments/assets/ad2b6c1e-c2d0-4b03-8773-4b9cb210890e)

<br>

![image](https://github.com/user-attachments/assets/d6551abe-fb28-48ce-b748-869d40b4368c)

<br>

![image](https://github.com/user-attachments/assets/539ef34f-308b-423f-919e-1e96f4629897)

<br>

# MySQL에 잘 들어갔는지 확인

```
[ec2-user@ip-10-0-1-107 testcode]$ ck8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com

    <h1>상품 관리</h1>
    <form method="POST" action="/add">
        <label for="item">물건 이름:</label><br>
        <input type="text" id="item" name="item"><br>
        <label for="price">가격:</label><br>
        <input type="number" id="price" name="price"><br><br>
        <button type="submit">추가</button>
    </form>
    <br>
    <a href="/items">저장된 상품 보기</a>

[ec2-user@ip-10-0-1-107 testcode]$ curl k8s-testcodeingressgr-269122aaa4-1288320504.ap-northeast-2.elb.amazonaws.com/items
<h1>저장된 상품 목록</h1><ul><li>Americano - 2000.00원</li><li>latte - 2500.00원</li></ul><br><a href='/'>상품 추가하기</a>
```

<br>
<br>
<br>
